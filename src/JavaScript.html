<script>
  // DOM Elements
  const statusEl = document.getElementById('status-message');
  const analyzeBtn = document.getElementById('analyze-btn');
  const folderPickerBtn = document.getElementById('folder-picker-btn');
  const docIdInput = document.getElementById('doc-id-input');
  
  // Playback Elements
  const playbackUI = document.getElementById('main-app-container');
  const playPauseBtn = document.getElementById('play-pause-btn');
  const slider = document.getElementById('timeline-slider');
  const paperContent = document.getElementById('paper-content');
  const listContainer = document.getElementById('document-list');
  
  const currentRevInfoEl = document.getElementById('current-rev-info');
  const currentRevDateEl = document.getElementById('current-rev-date');
  const speedSelector = document.getElementById('playback-speed');
  const jumpLatestBtn = document.getElementById('jump-latest-btn');
  const connectDbBtn = document.getElementById('connect-db-btn');
  const activeUnitTab = document.getElementById('active-unit-tab');

  // --- Playback Engine Class ---
  class PlaybackEngine {
    constructor() {
      this.revisions = [];
      this.currentIndex = 0;
      this.isPlaying = false;
      this.contentCache = {};
      this.fetchQueue = new Set();
      this.dmp = (typeof diff_match_patch !== 'undefined') ? new diff_match_patch() : null;
      this.activeDb = null;
      this.currentDocId = null;

      // Animation & Rendering
      this.animationFrameId = null;
      this.lastFrameTime = 0;
      this.speedConfig = {
        '2000': 0.5, // Slow
        '1000': 1.0, // Normal
        '400': 2.5,  // Fast
        '150': 5.0   // Turbo
      };
    }

    init() {
      const loadStatus = document.getElementById('loading-status');
      if(loadStatus) loadStatus.textContent = 'Setting up interface...';
      
      document.getElementById('loading-fallback').style.display = 'none';
      document.getElementById('main-app-container').classList.remove('hidden');
      document.getElementById('main-app-container').style.display = 'flex';
      
      // Defer database connection so UI shows up instantly
      setTimeout(() => {
        showStatus('Connecting to Analytics Database...', 'loading');
        handleConnectDb("ReVisor_Main_Database");
      }, 500);
    }

    reset() {
      this.stop();
      this.revisions = [];
      this.currentIndex = 0;
      this.contentCache = {};
      this.fetchQueue.clear();
      paperContent.innerHTML = '';
      document.getElementById('ai-insights-panel').classList.add('hidden');
      listContainer.innerHTML = '';
    }

    load(revisions, docId) {
      this.reset();
      this.revisions = revisions;
      this.currentDocId = docId;
      this.currentIndex = revisions.length - 1;

      this.renderHistoryList();
      this.setupTimeline();

      // Initial Load
      this.jumpTo(this.currentIndex, true);
    }

    stop() {
      this.isPlaying = false;
      playPauseBtn.textContent = '▶';
      if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
    }

    togglePlay() {
      if (this.isPlaying) this.pause();
      else this.play();
    }

    play() {
      this.isPlaying = true;
      playPauseBtn.textContent = '⏸';
      this.lastFrameTime = performance.now();
      this.animationFrameId = requestAnimationFrame((t) => this.tick(t));
    }

    pause() {
      this.stop();
    }

    async fetchBatch() {
      const BATCH_SIZE = 5;
      const LOOKAHEAD = 10;

      // Identify needed revisions (Lookahead + Previous for Diff)
      const neededIndices = [];
      if (this.currentIndex > 0) neededIndices.push(this.currentIndex - 1);
      for (let i = 0; i < LOOKAHEAD; i++) {
        const idx = this.currentIndex + i;
        if (idx >= 0 && idx < this.revisions.length) neededIndices.push(idx);
      }

      const missingRevisions = neededIndices
        .map(i => this.revisions[i])
        .filter(rev => rev && !this.contentCache[rev.id] && !this.fetchQueue.has(rev.id));

      if (missingRevisions.length === 0) return;

      // Take a batch
      const batch = missingRevisions.slice(0, BATCH_SIZE);
      const batchIds = batch.map(r => r.id);

      // Add to queue
      batchIds.forEach(id => this.fetchQueue.add(id));

      // Prepare URLs
      const urls = batch.map(rev => {
        const links = rev.exportLinks || {};
        // Prioritize CSV for Sheets, Plain Text for others
        if (links['text/csv']) return links['text/csv'];
        if (links['text/plain']) return links['text/plain'];
        return "https://docs.google.com/feeds/download/documents/export/Export?id=" + this.currentDocId + "&revision=" + rev.id + "&exportFormat=txt";
      });

      console.log('Fetching batch:', batchIds);
      if (this.isPlaying) showStatus('Buffering...', 'loading');

      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler((contents) => {
            batch.forEach((rev, i) => {
              if (contents[i] !== null) {
                this.contentCache[rev.id] = contents[i];
                // Mark UI as cached
                const el = document.getElementById("rev-item-" + this.revisions.indexOf(rev));
                if (el) el.classList.add('cached');
              } else {
                console.warn('Failed to fetch content for rev ' + rev.id);
              }
              this.fetchQueue.delete(rev.id);
            });
            if (this.isPlaying) showStatus('Playing...', 'success');
            else showStatus('Ready.', 'success');
            resolve();
          })
          .withFailureHandler((e) => {
            console.error('Batch fetch failed', e);
            batchIds.forEach(id => this.fetchQueue.delete(id));
            reject(e);
          })
          .apiFetchRevisionContentBatch(urls);
      });
    }

    async jumpTo(index, immediate = false) {
      if (index < 0 || index >= this.revisions.length) return;

      this.currentIndex = index;
      slider.value = index;

      // Update UI Info
      const rev = this.revisions[index];
      currentRevInfoEl.textContent = "Revision " + (index + 1) + " of " + this.revisions.length;
      currentRevDateEl.textContent = new Date(rev.modifiedDate).toLocaleString();

      // Highlight list item
      document.querySelectorAll('.revision-item').forEach(el => el.classList.remove('active'));
      const item = document.getElementById("rev-item-" + index);
      if (item) {
        item.classList.add('active');
        item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }

      // Check cache
      const prevRev = index > 0 ? this.revisions[index - 1] : null;

      if (this.contentCache[rev.id] && (!prevRev || this.contentCache[prevRev.id])) {
        // We have content, render immediately
        this.renderFrame(this.contentCache[rev.id], prevRev ? this.contentCache[prevRev.id] : null);
      } else {
        if (immediate) {
             showStatus('Buffering...', 'loading');
             await this.fetchBatch(); // Trigger urgent fetch
             // Try render again after fetch
             if (this.contentCache[rev.id]) {
                 this.renderFrame(this.contentCache[rev.id], prevRev ? this.contentCache[prevRev.id] : null);
             }
        } else {
          // Just trigger fetch for background
          this.fetchBatch();
        }
      }
    }

    renderFrame(cur, prev) {
       // Detect CSV (Basic heuristic: multiple lines and commas)
       if (cur && cur.split('\n').length > 1 && (cur.indexOf(',') > -1 || cur.indexOf('\t') > -1)) {
          this.renderCSV(cur, prev);
          return;
       }

       if (!prev || !this.dmp) {
         paperContent.innerHTML = escapeHtml(cur);
       } else {
         const diffs = this.dmp.diff_main(prev, cur);
         this.dmp.diff_cleanupSemantic(diffs);
         let html = '';
         diffs.forEach(d => {
           const op = d[0], txt = escapeHtml(d[1]);
           if (op === 1) html += '<ins class="diff-add">' + txt + '</ins>';
           else if (op === -1) html += '<del class="diff-del">' + txt + '</del>';
           else html += '<span>' + txt + '</span>';
         });
         paperContent.innerHTML = html;
       }
    }

    renderCSV(cur, prev) {
        const rows = cur.split('\n');
        let html = '<table style="border-collapse: collapse; width: 100%; font-size: 0.8rem;">';
        rows.forEach((row, rIdx) => {
            if (!row.trim()) return;
            html += '<tr>';
            // Regex to split CSV respecting quotes
            const cells = row.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
            cells.forEach(cell => {
                let txt = cell.replace(/^"|"$/g, '').replace(/""/g, '"');
                html += '<td style="border: 1px solid #ddd; padding: 4px;">' + escapeHtml(txt) + '</td>';
            });
            html += '</tr>';
        });
        html += '</table>';
        paperContent.innerHTML = html;
    }

    tick(timestamp) {
      if (!this.isPlaying) return;

      const speedVal = parseInt(speedSelector.value);
      // Heuristic: 1000 (Normal) -> 50ms per char step
      let msPerStep = speedVal / 20;
      if (msPerStep < 4) msPerStep = 4; // Cap max speed

      const elapsed = timestamp - this.lastFrameTime;

      if (elapsed >= msPerStep) {
        this.lastFrameTime = timestamp;
        const steps = Math.max(1, Math.floor(elapsed / msPerStep));
        this.advanceStep(steps);
      }

      this.animationFrameId = requestAnimationFrame((t) => this.tick(t));
    }

    advanceStep(steps) {
        // Ensure we have diffs for current -> next
        if (!this.diffState || this.diffState.fromIndex !== this.currentIndex) {
            this.prepareDiffState();
        }

        if (!this.diffState.valid) {
            // Cannot animate (e.g. end of history or error), just stop or jump
            if (this.currentIndex >= this.revisions.length - 1) {
                this.pause();
                return;
            }
            // If failed to get diff (e.g. loading), try to fetch
            if (!this.contentCache[this.revisions[this.currentIndex].id] ||
                !this.contentCache[this.revisions[this.currentIndex+1].id]) {
                 return; // Waiting for buffer
            }
            // Retry prep
            this.prepareDiffState();
            if (!this.diffState.valid) return;
        }

        // Advance cursor
        this.diffState.cursor += steps;

        // Check if finished revision
        if (this.diffState.cursor >= this.diffState.totalOps) {
             this.jumpTo(this.currentIndex + 1);
             this.diffState = null;
        } else {
             this.renderPartial(this.diffState);
        }
    }

    prepareDiffState() {
        const idx = this.currentIndex;
        const nextIdx = idx + 1;
        if (nextIdx >= this.revisions.length) {
            this.diffState = { valid: false };
            return;
        }

        const rev = this.revisions[idx];
        const nextRev = this.revisions[nextIdx];
        const content1 = this.contentCache[rev.id];
        const content2 = this.contentCache[nextRev.id];

        if (!content1 || !content2) {
             this.diffState = { valid: false };
             return;
        }

        if (this.isCSV(content2)) {
            // No typing animation for CSV, just jump
            this.diffState = { valid: true, isCSV: true, totalOps: 1, cursor: 0 };
            return;
        }

        const diffs = this.dmp.diff_main(content1, content2);
        this.dmp.diff_cleanupSemantic(diffs);

        // Calculate total INSERT chars to animate
        const totalInserts = diffs.reduce((acc, d) => (d[0] === 1 ? acc + d[1].length : acc), 0);

        this.diffState = {
            valid: true,
            fromIndex: idx,
            diffs: diffs,
            cursor: 0,
            totalOps: totalInserts > 0 ? totalInserts : 5 // Minimum frames if only deletes
        };
    }

    renderPartial(state) {
        if (state.isCSV) return;

        let html = '';
        let insertCursor = 0; // Tracks progress through ALL inserts

        for (let d of state.diffs) {
            const op = d[0];
            const text = escapeHtml(d[1]);

            if (op === 0) {
                // Equal: Always show
                html += '<span>' + text + '</span>';
            } else if (op === -1) {
                // Delete: Always show (or could animate removal, but keeping it simple)
                html += '<del class="diff-del">' + text + '</del>';
            } else if (op === 1) {
                // Insert: Animate
                const unescapedText = d[1];
                const len = unescapedText.length;

                if (insertCursor + len <= state.cursor) {
                    // Fully revealed
                    html += '<ins class="diff-add">' + text + '</ins>';
                    insertCursor += len;
                } else if (insertCursor < state.cursor) {
                    // Partially revealed
                    const revealCount = state.cursor - insertCursor;
                    const partial = escapeHtml(unescapedText.substring(0, revealCount));
                    html += '<ins class="diff-add">' + partial + '</ins>';
                    insertCursor += len; // We 'consumed' this chunk logic-wise
                } else {
                    // Not yet revealed
                    // html += '';
                    insertCursor += len;
                }
            }
        }
        paperContent.innerHTML = html;
    }

    isCSV(text) {
        return text && text.split('\n').length > 1 && (text.indexOf(',') > -1 || text.indexOf('\t') > -1);
    }

    renderHistoryList() {
      listContainer.innerHTML = '';
      this.revisions.forEach((rev, i) => {
        const el = document.createElement('div');
        el.className = 'revision-item';
        el.id = "rev-item-" + i;
        // Material List Item Structure
        el.innerHTML = '<span class="material-symbols-outlined" style="color:var(--md-sys-color-secondary); font-size:20px;">history</span>' +
          '<div style="flex:1;">' +
             '<strong class="body-medium">' + (rev.lastModifyingUserName || 'Unknown') + '</strong>' +
             '<div class="meta">' + new Date(rev.modifiedDate).toLocaleString(undefined, {dateStyle:'short', timeStyle:'short'}) + '</div>' +
          '</div>';
        el.onclick = () => this.jumpTo(i, true);
        listContainer.prepend(el);
      });
    }
    setupTimeline() {
      slider.disabled = false;
      slider.min = 0;
      slider.max = this.revisions.length - 1;
      slider.value = this.revisions.length - 1;
    }
  }

  const engine = new PlaybackEngine();

  // Initialization
  window.onload = function() {
    try {
      engine.init();
    } catch (e) {
      handleError({ message: 'Initialization failed: ' + e.message });
    }
  };

  // Event Listeners
  analyzeBtn.addEventListener('click', handleAnalyzeClick);
  folderPickerBtn.addEventListener('click', handleFolderPickerClick);
  connectDbBtn.addEventListener('click', () => {
    const name = prompt("Enter a Database/Unit Name (e.g. 'Grade 10 Unit 1' or '2026 Writing Portfolio'):");
    if (name) handleConnectDb(name);
  });
  playPauseBtn.addEventListener('click', () => engine.togglePlay());
  jumpLatestBtn.addEventListener('click', () => engine.jumpTo(engine.revisions.length - 1, true));
  slider.addEventListener('input', (e) => engine.jumpTo(parseInt(e.target.value), true));

  function handleFolderPickerClick() {
    const folderId = prompt("Please enter a Google Drive Folder ID or URL:");
    if (!folderId) return;
    showStatus('Fetching documents...', 'loading');
    google.script.run
      .withSuccessHandler(renderFolderDocs)
      .withFailureHandler(handleError)
      .apiListFolderDocs(folderId);
  }

  function renderFolderDocs(docs) {
    if (!docs || docs.length === 0) {
      showStatus('No docs found.', 'warning');
      return;
    }
    showStatus('Found ' + docs.length + ' docs.', 'success');
    listContainer.innerHTML = '<h3 class="label-large" style="margin: 0 0 8px 16px;">Select a Document</h3>';
    docs.forEach(doc => {
      const el = document.createElement('div');
      el.className = 'revision-item';
      el.innerHTML = '<span class="material-symbols-outlined" style="color:var(--md-sys-color-primary);">description</span>' +
        '<div style="flex:1;">' +
           '<strong class="body-medium">' + doc.name + '</strong>' +
           '<div class="meta">Updated: ' + new Date(doc.lastUpdated).toLocaleDateString() + '</div>' +
        '</div>';
      el.onclick = () => { docIdInput.value = doc.id; handleAnalyzeClick(); };
      listContainer.appendChild(el);
    });
  }

  function handleConnectDb(name) {
    google.script.run
      .withSuccessHandler((db) => {
        engine.activeDb = db;
        document.getElementById('db-prompt').style.display = 'none';
        document.getElementById('db-info').style.display = 'block';
        document.getElementById('db-link').href = db.url;
        document.getElementById('db-link').textContent = db.name;
        
        // Populate tabs
        activeUnitTab.innerHTML = '';
        db.tabs.forEach(t => {
          const opt = document.createElement('option');
          opt.value = t; opt.textContent = t;
          activeUnitTab.appendChild(opt);
        });
        showStatus('Database connected.', 'success');
      })
      .withFailureHandler(handleError)
      .apiConnectDatabase(name);
  }

  function handleAnalyzeClick() {
    let docId = docIdInput.value.trim();
    const rubric = document.getElementById('rubric-input').value.trim();
    if (!docId) return showStatus('Enter a Doc ID.', 'error');

    const urlMatch = docId.match(/\/d\/([a-zA-Z0-9-_]+)/);
    if (urlMatch && urlMatch[1]) docId = urlMatch[1];
    
    showProgress(true, 'Analyzing Document...', 10, 'Step 1/3: Fetching Revision History');
    
    google.script.run
      .withSuccessHandler((revisions) => {
        if (!revisions || revisions.length === 0) {
          showProgress(false);
          return showStatus('No history found.', 'warning');
        }
        
        engine.load(revisions, docId);
        showProgress(false); 
        showStatus('Ready.', 'success');
        
        // Parallelize: Run AI Analysis and auto-save
        google.script.run
          .withSuccessHandler((report) => {
            displayAnalysisResults(report);
            
            // AUTOMATIC DATABASE LOGGING
            if (engine.activeDb) {
              const tab = activeUnitTab.value;
              showStatus('Logging to ' + engine.activeDb.name + '...', 'loading');
              google.script.run
                .withSuccessHandler(() => showStatus('Analysis synced to database.', 'success'))
                .apiSaveAnalysis(report, tab);
            }
          })
          .withFailureHandler(handleError)
          .apiAnalyzeDocument(docId, rubric);
      })
      .withFailureHandler(handleError)
      .apiGetRevisions(docId);
  }

  function runAiAnalysis(docId, rubric) {
    google.script.run
      .withSuccessHandler(displayAnalysisResults)
      .withFailureHandler(handleError)
      .apiAnalyzeDocument(docId, rubric);
  }

  function displayAnalysisResults(report) {
    const panel = document.getElementById('ai-insights-panel');
    const content = document.getElementById('ai-content');
    panel.classList.remove('hidden');
    
    let html = '';
    if (report.aiInsight?.error) {
      html = '<div class="error-text" style="color:var(--md-sys-color-error);">AI unavailable: ' + report.aiInsight.error + '</div>';
    } else {
      const insight = report.aiInsight || {};
      html += '<h4 class="label-large">Process Evaluation</h4>';
      html += '<div class="flag-item"><span class="material-symbols-outlined" style="font-size:16px;">score</span> Consistency Score: <strong>' + (insight.voiceConsistency || '??') + '/100</strong></div>';
      html += '<div class="flag-item"><span class="material-symbols-outlined" style="font-size:16px;">school</span> Writing Level: <strong>' + (insight.vocabularyLevel || '??') + '</strong></div>';
      
      if (insight.rubricAlignment) {
        html += '<h4 class="label-large">Rubric Feedback</h4><p class="body-medium">' + insight.rubricAlignment + '</p>';
      }
      
      if (report.flags?.length) {
        html += '<h4 class="label-large">Process Flags</h4>';
        report.flags.forEach(f => {
          html += '<div class="flag-item" style="color:var(--md-sys-color-error);"><span class="material-symbols-outlined" style="font-size:16px;">warning</span> ' + f.type + ': ' + f.message + '</div>';
        });
      }

      if (report.processQuestions?.length) {
        html += '<h4 class="label-large">Conversation Starters</h4><ul style="margin:0; padding-left:20px;">';
        report.processQuestions.forEach(q => html += '<li class="body-medium">' + q + '</li>');
        html += '</ul>';
      }
    }
    content.innerHTML = html;
  }


  function showProgress(show, stepText = '', percent = 0, detailText = '') {
    const overlay = document.getElementById('progress-overlay');
    if (show) {
      overlay.classList.remove('hidden');
      document.getElementById('progress-bar-fill').style.width = percent + '%';
      document.getElementById('progress-detail').textContent = detailText;
      document.getElementById('progress-step').textContent = stepText;
    } else {
      overlay.classList.add('hidden');
    }
  }

  function showStatus(msg, type) {
    statusEl.textContent = msg;
    statusEl.style.color = type === 'error' ? '#d93025' : (type === 'success' ? '#1e8e3e' : '#5f6368');
  }

  function handleError(e) {
    showStatus('Error: ' + e.message, 'error');
    console.error(e);
    showProgress(false);
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
</script>
